class $fca228c3af8a0080$export$a829527ff4e4114a {
    constructor(element, callback){
        this.element = element;
        this.callback = callback;
        // Bind the 'resizeCanvas' method to the current context
        this.resizeCanvas = this.resizeCanvas.bind(this);
    }
    init() {
        // Create a new canvas element
        this.overlayCanvas = document.createElement("canvas");
        // Set the dimensions of the canvas to match the base image
        this.overlayCanvas.width = this.element.clientWidth;
        this.overlayCanvas.height = this.element.clientHeight;
        // Style the canvas to overlay the base image
        this.overlayCanvas.style.position = "absolute";
        this.overlayCanvas.style.left = this.element.offsetLeft + "px";
        this.overlayCanvas.style.top = this.element.offsetTop + "px";
        this.overlayCanvas.style.zIndex = "1000"; // High value to ensure it's on top
        this.ctx = this.overlayCanvas.getContext("2d");
        this.ctx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        // Append the overlay canvas to the same parent element as the base image
        this.element.parentElement.appendChild(this.overlayCanvas);
        // Add the resize event listener
        window.addEventListener("resize", this.resizeCanvas);
        // Call resizeCanvas initially to set the correct size from the start
        this.resizeCanvas();
    }
    resizeCanvas() {
        // Update the canvas dimensions to match the parent element's size
        this.overlayCanvas.width = this.element.clientWidth;
        this.overlayCanvas.height = this.element.clientHeight;
        // Update the style to reflect the new position if necessary
        this.overlayCanvas.style.left = this.element.offsetLeft + "px";
        this.overlayCanvas.style.top = this.element.offsetTop + "px";
        // Clear the canvas and call the callback if any drawing is required
        this.ctx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        if (this.callback) this.callback();
    }
    hide() {
        // Implement the hide functionality if needed
        this.overlayCanvas.style.display = "none";
    }
    show() {
        // Implement the show functionality if needed
        this.overlayCanvas.style.display = "block";
    }
    // Make sure to remove the event listener when the widget is no longer needed
    destroy() {
        window.removeEventListener("resize", this.resizeCanvas);
    // Perform any additional cleanup like removing the canvas if necessary
    }
}



class $f52c7bfdf3db710e$export$dd23631818154ff extends (0, $fca228c3af8a0080$export$a829527ff4e4114a) {
    constructor(element, callback){
        super(element, callback);
        this.rect = {};
        this.handleRadius = 2;
        this.dragTL = this.dragBL = this.dragTR = this.dragBR = false;
        this.dragWholeRect = false;
        super.init();
        this.initRect();
        this.drawRectInCanvas();
        this.attachResizeListeners();
    }
    initRect() {
        this.rect.height = 50;
        this.rect.width = 50;
        // this.rect.left = (window.innerWidth - this.rect.width) / 2;
        // this.rect.top = (window.innerHeight - this.rect.height) / 2;
        this.rect.left = (this.element.width - this.rect.width) / 2;
        this.rect.top = (this.element.height - this.rect.height) / 2;
    }
    drawRectInCanvas() {
        var ctx = this.overlayCanvas.getContext("2d");
        ctx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        ctx.beginPath();
        ctx.lineWidth = "1";
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
        ctx.strokeStyle = "#000000";
        ctx.rect(this.rect.left, this.rect.top, this.rect.width, this.rect.height);
        ctx.fill();
        ctx.stroke();
    }
    attachResizeListeners() {
        this.overlayCanvas.addEventListener("mousedown", this.mouseDown.bind(this), false);
        this.overlayCanvas.addEventListener("mouseup", this.mouseUp.bind(this), false);
        this.overlayCanvas.addEventListener("mousemove", this.mouseMove.bind(this), false);
    }
    mouseDown(e) {
        // ... implementation of mouseDown
        let pos = this.getMousePos(e);
        let mouseX = pos.x;
        let mouseY = pos.y;
        // 0. inside movable rectangle
        if (this.checkInRect(mouseX, mouseY, this.rect)) {
            this.dragWholeRect = true;
            this.startX = mouseX;
            this.startY = mouseY;
        } else if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top)) this.dragTL = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top)) this.dragTR = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.dragBL = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.dragBR = true;
        this.drawRectInCanvas();
    }
    // Add the rest of the helper functions like getMousePos, checkInRect, checkCloseEnough here.
    getMousePos(evt) {
        let clx = evt.clientX;
        let cly = evt.clientY;
        let boundingRect = this.element.getBoundingClientRect();
        return {
            x: clx - boundingRect.left,
            y: cly - boundingRect.top
        };
    }
    checkInRect(x, y, r) {
        return x > r.left && x < r.width + r.left && y > r.top && y < r.top + r.height;
    }
    checkCloseEnough(p1, p2) {
        return Math.abs(p1 - p2) < this.handleRadius;
    }
    mouseMove(e) {
        let pos = this.getMousePos(e);
        let mouseX = pos.x;
        let mouseY = pos.y;
        // Update the cursor style based on mouse position
        this.updateCursorStyle(mouseX, mouseY);
        if (this.dragWholeRect) {
            e.preventDefault();
            e.stopPropagation();
            let dx = mouseX - this.startX;
            let dy = mouseY - this.startY;
            if (this.rect.left + dx > 0 && this.rect.left + dx + this.rect.width < this.overlayCanvas.width) this.rect.left += dx;
            if (this.rect.top + dy > 0 && this.rect.top + dy + this.rect.height < this.overlayCanvas.height) this.rect.top += dy;
            this.startX = mouseX;
            this.startY = mouseY;
        } else if (this.dragTL) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(this.rect.left + this.rect.width - mouseX) + Math.abs(this.rect.height + this.rect.top - mouseY)) / 2;
            if (newSide > 50) {
                this.rect.left = this.rect.left + this.rect.width - newSide;
                this.rect.top = this.rect.height + this.rect.top - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragTR) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(mouseX - this.rect.left) + Math.abs(this.rect.height + this.rect.top - mouseY)) / 2;
            if (newSide > 50) {
                this.rect.top = this.rect.height + this.rect.top - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragBL) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(this.rect.left + this.rect.width - mouseX) + Math.abs(this.rect.top - mouseY)) / 2;
            if (newSide > 50) {
                this.rect.left = this.rect.left + this.rect.width - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragBR) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(mouseX - this.rect.left) + Math.abs(mouseY - this.rect.top)) / 2;
            if (newSide > 50) this.rect.width = this.rect.height = newSide;
        }
        this.drawRectInCanvas();
    }
    updateCursorStyle(mouseX, mouseY) {
        if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top)) this.overlayCanvas.style.cursor = "nwse-resize"; // Top left corner
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top)) this.overlayCanvas.style.cursor = "nesw-resize"; // Top right corner
        else if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.overlayCanvas.style.cursor = "nesw-resize"; // Bottom left corner
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.overlayCanvas.style.cursor = "nwse-resize"; // Bottom right corner
        else this.overlayCanvas.style.cursor = "default"; // Default cursor elsewhere
    }
    mouseUp(e) {
        this.dragTL = this.dragTR = this.dragBL = this.dragBR = false;
        this.dragWholeRect = false;
        this.storeCoordinates();
    }
    storeCoordinates() {
        // ... implementation of storeCoordinates
        let topleft = {
            x: this.rect.left,
            y: this.rect.top
        };
        let bottomright = {
            x: this.rect.left + this.rect.width,
            y: this.rect.top + this.rect.height
        };
        // console.log("Top Left:", topleft, "Bottom Right:", bottomright);
        this.callback(topleft, bottomright); // Invoke the callback with the coordinates
    }
} // Usage:
 // Assuming `callback` is a function that handles the top-left and bottom-right coordinates
 // And `element` is the canvas element to which the bounding box should be applied
 //   let element = document.getElementById('canvas');
 //   let resizableBox = new ResizableBBox(element);
 //   resizableBox.init();



class $e0e05d850538fde1$export$8a7a1b898028e86c extends (0, $fca228c3af8a0080$export$a829527ff4e4114a) {
    constructor(element, callback){
        super(element);
        this.callback = callback;
        this.isDrawing = false;
        this.startX = 0;
        this.startY = 0;
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
        super.init();
        this.overlayCanvas.style.cursor = "crosshair"; // Set the cursor to crosshair
        this.attachEventListeners();
    }
    attachEventListeners() {
        this.overlayCanvas.addEventListener("mousedown", this.mouseDown.bind(this));
        this.overlayCanvas.addEventListener("mousemove", this.mouseMove.bind(this));
        this.overlayCanvas.addEventListener("mouseup", this.mouseUp.bind(this));
        this.overlayCanvas.addEventListener("mouseout", this.mouseOut.bind(this));
    }
    mouseDown(e1) {
        var rect = e1.currentTarget.getBoundingClientRect();
        this.isDrawing = true;
        this.x1 = e1.clientX * window.devicePixelRatio - rect.left * window.devicePixelRatio;
        this.y1 = e1.clientY * window.devicePixelRatio - rect.top * window.devicePixelRatio;
        this.startX = e1.offsetX;
        this.startY = e1.offsetY;
        console.log("Mouse down at:", this.x1, this.y1);
    }
    mouseMove(e1) {
        if (!this.isDrawing) return;
        this.ctx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height); // Clear canvas
        let width = e1.offsetX - this.startX;
        let height = e1.offsetY - this.startY;
        console.log("Mouse Move at:", this.x1, this.y1);
        this.ctx.strokeRect(this.startX, this.startY, width, height);
    }
    mouseUp(e1) {
        this.isDrawing = false;
        var rect = e1.currentTarget.getBoundingClientRect();
        this.x2 = e1.clientX * window.devicePixelRatio - rect.left * window.devicePixelRatio;
        this.y2 = e1.clientY * window.devicePixelRatio - rect.top * window.devicePixelRatio;
        console.log("Mouse up at: ", this.x2, this.y2);
        this.storeCoordinates();
    }
    mouseOut() {
        if (this.isDrawing) {
            // Store coordinates also when the mouse accidentally leaves the canvas
            var rect = e.currentTarget.getBoundingClientRect();
            this.x2 = e.clientX * window.devicePixelRatio - rect.left * window.devicePixelRatio;
            this.y2 = e.clientY * window.devicePixelRatio - rect.top * window.devicePixelRatio;
            console.log("Mouse out at: ", this.x2, this.y2);
            this.storeCoordinates();
        }
        this.isDrawing = false;
    }
    storeCoordinates() {
        let topleft = {
            x: this.x1,
            y: this.y1
        };
        let bottomright = {
            x: this.x2,
            y: this.y2
        };
        this.callback(topleft, bottomright); // Invoke the callback with the coordinates
    }
} // Usage:
 // Assuming `callback` is a function that handles the top-left and bottom-right coordinates
 // And `element` is the canvas element to which the bounding box should be applied
 // let element = document.getElementById('canvas');
 // let bbox = new BBox(element, callback);
 // bbox.init();


class $5018ea9c30d774e7$export$247262aa28c26769 {
    constructor(){}
    createResizableBBox(element, callback) {
        console.log("Resizable BBox");
        return new (0, $f52c7bfdf3db710e$export$dd23631818154ff)(element, callback);
    }
    createDraggableBBox(element, callback) {
        console.log("Draggable BBox");
        return new (0, $e0e05d850538fde1$export$8a7a1b898028e86c)(element, callback);
    }
}



// register global namespace with a new BoxCraft instance
window.BoxCraft = new (0, $5018ea9c30d774e7$export$247262aa28c26769)();
window.console.log("BoxCraft VERSION 0.1-alpha");


//# sourceMappingURL=boxCraft.min.js.map
